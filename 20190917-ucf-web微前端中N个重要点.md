##  一、model定义

### 背景

在传统的开发模式中，没有用到复杂的状态管理，只是应用了组件内部的State以及对外的Props属性，相对于简单的应用开发是可以满足的。当遇到复杂的应用后，组件内部的状态过多，维护起来也就越复杂，组件之间的"信息"传递也变得十分困难，稍不注意就会出现各种令开发者头疼的问题。

Redux、Mobx等状态管理解决方案的出现在技术上解决了开发者的难题，但上手门槛较高、概念多、样板式代码等问题也随之暴露，“当年的屠龙少年，自己变成了一条龙”。

### mirrorx -- 更简单清晰的解决方案

基于以上实践考虑，我们在ucf-web中选择引入mirrorx模型框架来解决这个令人困扰的问题，它并不是横空出世的新物种，它只是在Redux之上的衍生解决方案，继承了Redux的单一数据源、数据不可变、纯函数执行等三大原则的优势，并解决了概念多、样板式代码、状态树维护难等问题。

使用mirrorx,主要工作在于如何定义model文件。

### 定义model

一个基本的model的样子如下：

```javascript
/**
*数据模型类
*/
export default {
    name:"app",
    initialState:{
        
    },
    reducers:{
        updateState(state,data) {
            return {
                ...state,
                ...data
            };
        }
    },
    effects:{
        
    }
};
```

可以看出仅仅只有4个字段(name、initialState、reducers、effects)，下面是这4个字段的详细解读及具体使用方法。

### name

> 模型的名称，每一个业务对应一个模型，通过该字段的定义来找到对应的方法。

要创建model，必须指定name,且为一个合法字符串。name很好理解，就是model的名称，这个名称会用于后面创建的Redux store里的命名空间。

假设定义了一个这样的model:

```javascript
export default {
	name:'app'
};
```

那么后面创建的Redux store会是这样的结构

```javascript
store.getState(); // { app:null	}
```

可以看到，model的name就是其state在根store下的命名空间(当然，name对全局actions也非常重要，见下文)。

另外，需要注意的是，上面创建的store,其app这个state的值是null。假如你需要一个不同的、更有意义的值，那么你就需要指定一个initialState。

> **注意：**mirror使用了react-router-redux,因此不可以使用routing做为model的name值。

### initialState

initialState也很容易理解，表示model的初始state。在创建标准的Redux reducer时，它就表示这个reducer的initialState。

常规组件内部的state应该写在这里，这个值不是必需的，而且可以为任意值。如果没有指定initialState，那么它的值就是null。

创建model:

```javascript
export default {
	name:'app',
    initialState:{
        num : 0
    }
};
```

得到的store:

```js
Store.getState(); // { app : { num:0 } }
```

### reducers

mirror app所有的Redux reducer都是在reducers中定义的，reducers对象中的方法本身会用于创建reducer,方法的名字会用于创建action type。mirror的原则是，一个reducer只负责一个action,所以你不需要关心你要处理的action具体的type是什么。

reducers里面的方法是同步的，并且是纯函数：

```js
export default {
	name : 'app',
	initialState : {
        num ： 0
    },
    reducers : {
		add(state,data) {
            return state + data
        }
	}
};
```

### effects 

所谓的effects就是Redux的异步action (async action)。在函数式编程中，effect表示所有会与函数外部发生交互的操作。在Redux的世界里，异步的action显然是effect。

effect不会直接更新Redux state,通常是在完成某些异步操作（例如AJAX请求）之后，再调用其他的<font color=#b00 size=2>“同步action”</font>来更新state。

和reducers对象类似，在effects中定义的所有方法都会以相同名称添加到actions.modelName上，在其他组件中可调用这些方法。

```js
export default {
    name : 'app' ,
    initialState : {
  		num : 0      
    },
    reducers : {
        add (state,data) {
            return state + data
        }
    },
    effects : {
        async myEffect(data,getState) {
            const res = await Promise.resolve(data)
            actions.app.add(res)
        }
    }
};
```

执行上述代码，actions.app就会拥有两个方法：actions.app.add和actions.app.myEffect。调用actions.app.myEffect，就会调用effect.myEffect。

在effects中定义的方法接收两个形参：

1.data - 调用actions.modelName上的方法所传递的data，可选；

2.getState - 实际上就是store.getState，返回当前action被dispatch前的store的数据，同样是可选的；

### model注册到store

```js
import mirror from 'mirrorx'
import model from './model.js'
mirror.model(model)
```

### model与UI组件双向绑定

````js
import mirror,{ connect } from 'mirrorx'
import model from './model.js'
mirror.model(model)

import App from './container.js';
const ConnectedApp = connect(state => state.app)(App);
export default ConnectedApp;
````

这里需要注意的是，UI组件与model组件绑定后，UI组件即可通过<font color=#b00>**this.props**</font> 访问model中的数据, UI组件被引用时，如需获取store中的数据，需要使用包装后的组件，如上述例子中的<font color=#b00>ConnectedApp</font>组件。







 

