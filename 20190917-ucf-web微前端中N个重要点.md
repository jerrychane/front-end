##  model定义

### 背景

在传统的开发模式中，没有用到复杂的状态管理，只是应用了组件内部的State以及对外的Props属性，相对于简单的应用开发是可以满足的。当遇到复杂的应用后，组件内部的状态过多，维护起来也就越复杂，组件之间的"信息"传递也变得十分困难，稍不注意就会出现各种令开发者头疼的问题。

Redux、Mobx等状态管理解决方案的出现在技术上解决了开发者的难题，但上手门槛较高、概念多、样板式代码等问题也随之暴露，“当年的屠龙少年，自己变成了一条龙”。

### mirrorx -- 更简单清晰的解决方案

基于以上实践考虑，我们在ucf-web中选择引入mirrorx模型框架来解决这个令人困扰的问题，它并不是横空出世的新物种，它只是在Redux之上的衍生解决方案，继承了Redux的单一数据源、数据不可变、纯函数执行等三大原则的优势，并解决了概念多、样板式代码、状态树维护难等问题。

使用mirrorx,主要工作在于如何定义model文件。

### 定义model

一个基本的model的样子如下：

```javascript
/**
*数据模型类
*/
export default {
    name:"app",
    initialState:{
        
    },
    reducers:{
        updateState(state,data) {
            return {
                ...state,
                ...data
            };
        }
    },
    effects:{
        
    }
};
```

可以看出仅仅只有4个字段(name、initialState、reducers、effects)，下面是这4个字段的详细解读及具体使用方法。

### name

> 模型的名称，每一个业务对应一个模型，通过该字段的定义来找到对应的方法。

要创建model，必须指定name,且为一个合法字符串。name很好理解，就是model的名称，这个名称会用于后面创建的Redux store里的命名空间。

假设定义了一个这样的model:

```javascript
export default {
	name:'app'
};
```

那么后面创建的Redux store会是这样的结构

```javascript
store.getState(); // { app:null	}
```

可以看到，model的name就是其state在根store下的命名空间(当然，name对全局actions也非常重要，见下文)。

另外，需要注意的是，上面创建的store,其app这个state的值是null。假如你需要一个不同的、更有意义的值，那么你就需要指定一个initialState。

> **注意：**mirror使用了react-router-redux,因此不可以使用routing做为model的name值。

### initialState

initialState也很容易理解，表示model的初始state。在创建标准的Redux reducer时，它就表示这个reducer的initialState。

常规组件内部的state应该写在这里，这个值不是必需的，而且可以为任意值。如果没有指定initialState，那么它的值就是null。

创建model:

```javascript
export default {
	name:'app',
    initialState:{
        num : 0
    }
};
```

得到的store:

```js
Store.getState(); // { app : { num:0 } }
```

### reducers

mirror app所有的Redux reducer都是在reducers中定义的，reducers对象中的方法本身会用于创建reducer,方法的名字会用于创建action type。mirror的原则是，一个reducer只负责一个action,所以你不需要关心你要处理的action具体的type是什么。

reducers里面的方法是同步的，并且是纯函数：

```js
export default {
	name : 'app',
	initialState : {
        num ： 0
    },
    reducers : {
		add(state,data) {
            return state + data
        }
	}
};
```

### effects 

所谓的effects就是Redux的异步action (async action)。在函数式编程中，effect表示所有会与函数外部发生交互的操作。在Redux的世界里，异步的action显然是effect。



 

