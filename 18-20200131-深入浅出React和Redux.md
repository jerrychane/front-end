#####  第1章 React 新的前端思维方式

1.全局安装create-react-app脚手架

```shell
npm install --global create-react-app
```

2.所谓组件，简单说，指的是能完成某个特定功能的独立的，可重复的代码。

3.做同一件事的代码应该有高耦合性。

4.React的理念，归结为一个公式 UI = render(data)，开发者只需关注渲染，而不用关心如何实现增量渲染。

5.所谓纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数调用如果输入相同，得到的结果也绝对相同。

6.React利用Virtual DOM,让每次渲染都只重新渲染最少的DOM元素。Virtual DOM是对DOM树的抽象，本质上是一个对象。

##### 第2章 设计高质量的React组件

1.作为软件设计的通则，组件的划分要满足高类聚(Hign Cohesion)和低耦合(Low Coupling)的原则。高内聚指的是把逻辑紧密相关的内容放在一个组件中；低耦合指的是不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立。

2.差劲的程序员操心代码，优秀的程序员操心数据结构和他们之间的关系。(Linus Torvalds,Linux 创始人)

3.当prop的类型不是字符串类型时，在JSX中必须用花括号 {} 把 prop 值包住，所以 style 的值有两层括号，外层花括号代表是 JSX 的语法，内层花括号代表这是一个对象常量。

4.React 利用 prop 来定义组件的对外接口，用 state 来代表内部的状态，某个数据选择用 prop 还是用 state 表示，取决于这个数据是对外还是对内。

##### 第3章 从 Flux 到 Redux

1.一个 store 也是一个对象，这个对象存储应用状态，同时还要接受 Dispatcher 派发的动作，根据动作来决定是否要更新应用状态。

2.reducer 函数不光接受 action 为参数，还接受 state 为参数。也就是说，Redux 的 reducer 只负责计算状态，却并不负责存储状态。

``` javascript
	function reducer(state,aciton) => {
		const {counterCaption} = action;
		switch (action.type) {
			case ActionTypes.INCREMENT:
				return {...state,[counterCaption]:state[counterCaption] + 1};
			case ActionTypes.DECREMENT;
            	return {...state,[counterCaption]:state[counterCaption] - 1};
            default:
            	return sate;
		}
	}
```

3.Redux三个基本原则：唯一数据源( Single Source of Truth ); 保持状态只读 ( State is read-only ); 数据改变只能通过纯函数来完成( Changes are made with pure functions )。

4.在计算机编程的世界里，完成任何一件事，可能都有一百种以上的方法，但无节制的灵活度反而让软件难以维护，增加限制是提高软件质量的法门。

5.在 Redux 框架下，一个 React 组件 基本上就是要完成以下两个功能：第一，和 Redux Store 打交道，读取 Store 的状态，用于初始化组件的状态，同时还要监听 Store 的状态变化； 当 Store 状态发生变化时，需要更新组件状态，从而驱动组件重新渲染；当需要更新 Store 状态时，就要派发 action 对象；第二，根据当前的 props 和 state , 渲染出用户界面；

6.每个 Redux 应用只能有一个 Redux Store,在整个 Redux 的生命周期中都应该保持 Store的唯一性。

##### 第4章  模块化 React 和 Redux 应用

1.从架构出发，开始实施一个新应用的时候，需要提前考虑的三件事：代码文件的组织结构；确定模块的边界；Store 的状态树。

2.reducer 目录包含所有 Redux 的 reducer; actions 目录包含所有 action 构造函数；components 目录包含所有的傻瓜组件； containers 目录包含所有的容器组件。

3.在最理想的情况下，我们应该通过增加代码就能增加系统的功能，而不是通过对现有代码的修改来增加功能。( Rober C.Martin)

4.不同功能模块之间的依赖关系应该简洁而清晰，也就是所谓的保持模块之间的低耦合性；一个模块应该把自己的功能封装的很好，让外界不要太依赖与自己内部的结构，这样不会因为内部的变化而影响外部模块的功能，这就是所谓高内聚性。

5.JSX中可以使用任何形式的 JavaScript 表达式，只要 JavaScript 表达式出现在符号 {} 之间，但是也只能是  JavaScript “表达式” , for 或者 while 产生的是语句而不是表达式，所以不能出现 for 或者 while。

6.import 语句不能够存在于条件语句中，只能出现在模块语句的顶层位置。

##### 第5章 React 组件性能优化

1.“过早的优化是万恶之源。” --- 高德纳

2.“我们应该忘记忽略很小的性能优化，可以说97%的情况下，过早的优化是万恶之源，而我们应该关心对性能影响最关键的那另外3%的代码。” --- 高德纳

3.在自己的工作中一定要有量化的性能指标。

4.对于 DOM 元素类型，React 会保留节点对应的 DOM 元素，只对树形结构根节点上的属性和内容做一下对比，然后只更新修改的部分。

5.利用 react-redux 提供过的 shouldComponentUpdate 实现来提高组件渲染功能的方法，一个要诀就是避免传递给其他组件的 prop 值是一个不同的对象，不然会造成无谓的重复渲染。

##### 第6章 React 高级组件

1.一个高阶组建就是一个函数，这个函数接受一个组件作为输入，然后返回一个新的组件作为输出，而且，返回的新组件拥有了输入组件所不具有的功能。这里提到的组件指的并不是组件实例，而是一个组件类，也可以是一个无状态组件的函数。

2.定义高阶组件的意义何在呢？首先，重用代码；其次，修改现有 React 组件的行为。根据返回的新组件和传入组件参数的关系，高阶组件的实现方式可以分为两大类：代理方式的高阶组价和继承方式的高阶组件。




























