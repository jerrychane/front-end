#####  第1章 React 新的前端思维方式

1.全局安装create-react-app脚手架

```shell
npm install --global create-react-app
```

2.所谓组件，简单说，指的是能完成某个特定功能的独立的，可重复的代码。

3.做同一件事的代码应该有高耦合性。

4.React的理念，归结为一个公式 UI = render(data)，开发者只需关注渲染，而不用关心如何实现增量渲染。

5.所谓纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数调用如果输入相同，得到的结果也绝对相同。

6.React利用Virtual DOM,让每次渲染都只重新渲染最少的DOM元素。Virtual DOM是对DOM树的抽象，本质上是一个对象。

##### 第2章 设计高质量的React组件

1.作为软件设计的通则，组件的划分要满足高类聚(Hign Cohesion)和低耦合(Low Coupling)的原则。高内聚指的是把逻辑紧密相关的内容放在一个组件中；低耦合指的是不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立。

2.差劲的程序员操心代码，优秀的程序员操心数据结构和他们之间的关系。(Linus Torvalds,Linux 创始人)

3.当prop的类型不是字符串类型时，在JSX中必须用花括号 {} 把 prop 值包住，所以 style 的值有两层括号，外层花括号代表是 JSX 的语法，内层花括号代表这是一个对象常量。

4.React 利用 prop 来定义组件的对外接口，用 state 来代表内部的状态，某个数据选择用 prop 还是用 state 表示，取决于这个数据是对外还是对内。

##### 第3章 从 Flux 到 Redux

1.一个 store 也是一个对象，这个对象存储应用状态，同时还要接受 Dispatcher 派发的动作，根据动作来决定是否要更新应用状态。

2.reducer 函数不光接受 action 为参数，还接受 state 为参数。也就是说，Redux 的 reducer 只负责计算状态，却并不负责存储状态。

``` javascript
	function reducer(state,aciton) => {
		const {counterCaption} = action;
		switch (action.type) {
			case ActionTypes.INCREMENT:
				return {...state,[counterCaption]:state[counterCaption] + 1};
			case ActionTypes.DECREMENT;
            	return {...state,[counterCaption]:state[counterCaption] - 1};
            default:
            	return sate;
		}
	}
```

3.Redux三个基本原则：唯一数据源( Single Source of Truth ); 保持状态只读 ( State is read-only ); 数据改变只能通过纯函数来完成( Changes are made with pure functions )。

4.在计算机编程的世界里，完成任何一件事，可能都有一百种以上的方法，但无节制的灵活度反而让软件难以维护，增加限制是提高软件质量的法门。

5.在 Redux 框架下，一个 React 组件 基本上就是要完成以下两个功能：第一，和 Redux Store 打交道，读取 Store 的状态，用于初始化组件的状态，同时还要监听 Store 的状态变化； 当 Store 状态发生变化时，需要更新组件状态，从而驱动组件重新渲染；当需要更新 Store 状态时，就要派发 action 对象；第二，根据当前的 props 和 state , 渲染出用户界面；

6.每个 Redux 应用只能有一个 Redux Store,在整个 Redux 的生命周期中都应该保持 Store的唯一性。

##### 第4章  模块化 React 和 Redux 应用

1.从架构出发，开始实施一个新应用的时候，需要提前考虑的三件事：代码文件的组织结构；确定模块的边界；Store 的状态树。

2.reducer 目录包含所有 Redux 的 reducer; actions 目录包含所有 action 构造函数；components 目录包含所有的傻瓜组件； containers 目录包含所有的容器组件。