### **目标**：12月20日前完成webpack4实战课程的学习！

webpack和webpack-cli之间的关系是什么？

### 安装webpack	

npm init 帮助我们以node规范的方式创建一个项目或者创建一个node的包文件，最终的结果就是在项目目录下生成一个package.json文件。

```js
npm init / npm init -y (自动生成默项)
npm install webpack webpack-cli --save-dev
```

### 运行webpack

```js
npx webpack index.js // 用webpack翻译index.js文件
```

注意： 

1. npx 和 npm 的区别，其实很简单，npx会在目录下的node_modules下面找webpack，没有就安装一个。npm 则先去全局，然后再去当前目录下的node_modules找webpack，没有就不找了；
2. devDependencies 和 dependencies的区别，devDependencies 指的是你本地开发环境下的依赖(比如webpack，babel以及一系列的loader等)；dependencies 指的是你生产环境下打包所需要的依赖(比如你项目中用到了lodash，那么你就应该配置到这个下边)

### webpack环境搭建

webpack是基于nodejs开发的模块打包工具。提升webpack打包速度，一定要安装最新稳定版本。

(1) node版本要使用最新稳定版；（2）webpack要使用最新版本；

### webpack的安装方式

**全局安装：**

`npm install webpack webpack-cli -g`; (安装时，如果npm安装很慢，建议使用手机分享热点，就不会有该问题了)

webpack-cli@3.1.2   webpack@4.26.0

全局安装特定版本：`npm install webpack@4.26.0 webpack-cli -g`;

不推荐使用webpack全局安装；卸载全局安装的webpack `npm uninstall webpack webpack-cli -g`

**项目中安装：**

`npm install webpack webpack-cli --save-dev   `  或者`npm install webpack webpack-cli -D`

其中--save-dev等价于-D；

安装特定版本：

`npm install webpack@4.26.0 webpack-cli@3.1.2 --save-dev`

此时无法运行webpack命令，如果要运行webpakc命令，需要执行` npx webpack -v`, 输出webpack版本

`npm info webpack`  or  `npm view webpack versions`  当不知道某个版本号是否存在时，查看webpack的所有版本号

### webpack的配置文件

创建默认配置文件 --- webpack.config.js，默认文件名必须是wepack.config.js；若要修改默认文件名，可用以下命令：

```js
npx webpack --config  webpackconfig.js // 修改默认配置文件名为 webpackconfig.js
```

```js
// webpack.config.js
const path = require('path');
module.exports = {
    mode:'production', // 开发环境: development，bundle.js中代码不会被压缩
    entry : './src/index.js',
     /* entry :  {
        main: './src/index.js'
    },*/
    output : {
       filename:'bundle.js',
       path:path.resolve(__dirname,'dist') // 绝对路径:打包后的文件放在什么目录下
    }
}
```

配置打包命令时，可用npm script 替代 npx webpack，需在package.json文件中进行配置，如下，运行npm run bundle即可

```json
scripts:{
    "bundle" : "webpack"
}
```

webpack-cli的作用就是使得我们可以使用 npx webpack 或 webpack 的命令。webpack默认的打包的模式是production。

### 什么是Loader

webpack 是什么？ 模块是什么？(js,html, css,图片,其他文件) webpack的配置文件的作用是什么？

loader 本质是一个打包的方案，它知道对于某一个特定的文件，webpack应该怎样打包，因为webpack无法识别非.js结尾的模块，loader在module中配置。安装file-loader : `npm install file-loader --save-dev`。file-loader能够处理任何静态资源的文件，不止图片，例如excel，word , ppt，txt等。 file-loader底层的原理是:第一步,将文件移动到dist目录下；第二步：把该文件的地址返回给变量。

```js
module:{
        // rules 是一个对象数组
        rules:[{ 
            test:/\.(jpg|png|gif)$/,
            use:{
                loader:'file-loader',
                options:{
                    // placeholder 占位符语法
                    name:'[name]_[hash].[ext]', // 图片文件以原来的名字输出
                    outputPath:'images/'
                }
            }
        }]
    },
```

url-loader 除了能做 file-loader 做的事情，还能做额外的事情，url-loader会将图片转换成一个base64的字符串，安装 url-loader :`npm install url-loader --save-dev`; 当图片非常小时，

```js
module:{
        rules:[{
            test:/\.(jpg|png|gif)$/,
            use:{
                loader:'url-loader',
                options:{
                    // placeholder 占位符语法，需要加引号，为字符串
                    name:'[name]_[hash].[ext]', // 图片文件以原来的名字输出
                    outputPath:'images/',
                    limit:2048 // 大于limit，生成图片文件; 小于limit，生成base64字符串
                }
            }
        }]
    },
```

### Vue Loader 是什么

Vue Loader 是一个 webpack 的 loader，它允许你以一种单文件组件的格式撰写 Vue 组件：

```vue
<template>
	<div class="example">
        {{ msg }}
    </div>
</template>
<script>
    export default {
        data() {
            return {
                msg:'Hello Vue!'
            }
        }
    }
</script>
<style>
    .example {
        color:red;
    }
</style>
```

### 使用 loader 打包静态资源(样式篇一)

为了使webpack能够识别css文件，需要引入 style-loader , css-loader; 其中css-loader可以帮助我们识别几个.css文件之间的关系，最终帮我们合并成一段css；style-loader 是在得到 css-loader生成的内容之后，style-loader会将这段内容挂载在head部分，生成`<style>...</style>` ; 若要识别 .scss文件，还要引入 sass-loader。

安装loader：

```
npm install style-loader css-loader --save-dev
```

在webpack.config.js中配置:

```js
 {
   test: /\.css$/,
   use: ['style-loader','css-loader','sass-loader','postcss-loader'] 
 }
```

安装sass-loader:

```js
npm install sass-loader node-sass --save-dev
```

问题描述：执行上述命令后，执行 `npm run bundle` , 项目报错：`TypeError: this.getResolve is not a function`

错误原因：安装 sass-loader 的版本为最新版本，由于版本过高，而导致编译出错；

解决方法：进入npm官方网站，搜索sass-loader，查看发布的版本号，选择一年前或两年前的低版本。我选择的是7.3.0版本，继续执行安装命令：

```js
npm install sass-loader@7.3.0 node-sass --save-dev
```

在webpack中loader是有先后顺序的，按照**从下到上，从右到左**的执行顺序。例如以上文件中，首先通过sass-loader对sass文件进行翻译，翻译成css代码以后，给到css-loader，然后都处理好，通过style-loader挂载到页面上。

在写css3新特性时，一般要加浏览器厂商前缀，可以通过 postcss-loader ,自动添加各个浏览器厂商的前缀。首先安装 postcss-loader ,然后创建 postcss.config.js  文件，在该文件中写入配置规则。

```
npm i -D postcss-loader // 安装 post-loader
```

```
npm install autoprefixer -D // 安装 autoprefixer plugin
```

在postcss.config.js中配置：

```js
module.exports = {
    plugins: [
        require('autoprefixer')
    ]
}
```

**遇到的坑：**

```scss
//scss中写的代码
body {
    .avatar {
        width: 150px;
        height: 150px;
        transform: translate(100px,100px);
    }
}
```

结果在编译至css代码时，并未加上-webkit-前缀，需要在package.json中加入browserslist，其他地方无需任何修改，代码如下：

```json
"browserslist": [
    "> 1%",
    "last 2 versions",
    "not ie <= 8"
  ],
```

### 使用 loader 打包静态资源(样式篇二)

css-loader中常用的配置项：

```js
use: [
    'style-loader', 
    {
        loader:'css-loader',
        options:{ 
            importLoaders:2, // 以import引入的.scss文件，也要走postcss-loader和scss-loader的2个loader
             modules:true, // css文件的模块化打包，区分不同css的作用域
        }
    }, 
    'sass-loader',
    'postcss-loader'
]
```

在使用时，引入时 import style from './index.scss';

```js
import avatar from "./avatar.jpg";
import style from './index.scss';
import createAvatar from './createAvatar';
// 调用createAvatar()函数
createAvtar();

var img = new Image();
img.src = avatar;
img.classList.add(style.avatar);// 只控制当前页面中img的样式，不影响createAvatar()中的样式

var root = document.getElementById('root');
root.append(img);
```

使用 file-loader打包字体文件:

```JS
{
    test: /\.(eot|ttf|svg|woff|woff2)$/,
        use: {
            loader: 'file-loader',
        } 
}
```

### 使用plugins让打包更便捷

安装 html-webpack-plugin:

```shell
npm install html-webpack-plugin --save-dev // html-webpack-plugin@3.2.0
```

在 webpack.config.js 中的配置 plugins 数组：

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  entry: 'index.js',
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'index_bundle.js'
  },
    
  plugins: [new HtmlWebpackPlugin({ // 实例化HtmlWebpackPlugin,在打包之后运行
      template:'src/index.html' // dist目录中index.html的模板文件
  })]
};
```

**HtmlwebpackPlugin的作用，会在打包结束后，自动生成一个html文件，并把打包生成的js自动注入到这个html文件中。**

webpack 中的 plugin 可以在webpack运行到某个时刻的时候（例如，htmlwebpackPlugin在打包结束的时刻），帮你做一些事情，类似于 vue 和 react 中的生命周期函数。

安装 clean-webpack-plugin，第三方的plugin：

```shell
npm install clean-webpack-plugin --save-dev // clean-webpack-plugin@1.0.0
```

在webpack.config.js中的配置：

```js
var CleanWepackPlugin = require('clean-webpack-plugin');
var path = require('path');

module.exports = {
  entry: 'index.js',
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'index_bundle.js'
  },
  plugins: [new CleanWepackPlugin(['dist'])]// 实例化CleanWebpackPlugin，在打包前运行
};
```

clean-webpack-plugin的作用是，在打包前删除上一次打包生成的文件。对比html-webpack-plugin和clean-webpack-plugin:  前者是在打包后执行(可通过控制台查看顺序)；后者是在打包前执行。

### Entry 与 Output 的基本配置

entry的入口文件可以写成一个字符串，表示打包文件的路径；output默认生成的文件为main.js。如果要将同一个文件，打包生成两个或多个文件，需要使用**占位符**( [name] / [hash] )。与此同时，会将打包生成的文件，放在template:'src/index.html'文件中。

```js
module.exports = {
	mode: 'development',
	entry: {
		main: './src/index.js',
		sub:'./src/index.js'
	},
	output: {
		filename: '[name].js', // name的值为entry中对象的key值，即main.js 和 sub.js
		path: path.resolve(__dirname, 'dist')
	}
}
```

在打包生成的文件前加入统一的地址,如引入CDN地址，需要在output中加上**publicPath**

```	js
module.exports = {
	mode: 'development',
	entry: {
		main: './src/index.js',
		sub:'./src/index.js'
	},
	output: {
        publicPath:'http://cdn.jerrychane.com',
		filename: '[name].js', // name的值为entry中对象的key值，即main.js 和 sub.js
		path: path.resolve(__dirname, 'dist')
	}
}
```

### SouceMap的配置

在开发者模式(mode:'development')，默认sourceMap已经配置,如果要关掉soucemap，可设置 devtool:'none';  souceMap本质上是一个映射关系，可以映射出打包后文件的源代码所在源文件所在的位置。

开启这种映射关系，可设置devtool:'source-map',在打包时，会在dist目录下生成`*.js.map`的文件；若要去掉dist目录下的`*.js.map`文件可设置 devtool:'inline-source-map', 将*.js.map里内容直接放在打包文件的底部，变成base64位的一段代码;

```js
devtools:'inline-source-map'; // 可以精确到哪一行的哪一列的记录，这样的映射很耗费性能
devtools:'cheap-inline-source-map'; // 可以精确到哪一行的记录，不用告诉哪一列，这样可以提高性能，只映射业务代码，不会管第三方的loader
devtools:'cheap-module-inline-source-map';// 映射业务代码和第三方的loader
devtool:'eval';// 通过eval执行js代码，执行效率最快，性能最好，但复杂代码慎用
```

最佳实践：在开发环境(mode: 'devlopment')中使用sourceMap，最好使用`devtool:'cheap-module-eval-source-map'`;在生产环境(线上环境mode: 'production')建议使用`devtool:'cheap-module-source-map'`。

cheap 可以提升打包速度，eval是打包速度最快，性能最好的方式, 原因是 eval 是通过eval的执行形式来生成sourceMap的映射关系。

### 使用WebpackDevServer提升开发效率

实现代码即时更新有三种方法：

第一种,在package.json中添加watch监听配置：

```js
"scripts": {
    "watch": "webpack --watch", // 运行npm run watch，监听源文件代码的修改，实现自动打包,但无法实现自动打开浏览并刷新的特性
  },
```

第二种，在webpack.config.js中添加devServer配置(推荐使用)：

首先要在当前项目中安装webpack-dev-server，安装命令如下：

```js
npm install webpack-dev-server -D // 安装webpack-dev-server@3.1.10
```

```js
# webpack.config.js
devServer:{
		contentBase:'./dist', // web服务器的地址即根路径下的dist目录，默认是localhost:8080
        open:true, // 自动打开浏览器,自动访问服务器地址
        port:8081,
    	proxy: {
      			 '/api': 'http://localhost:3000' // 配置代理地址
        }
	},
# package.json
 "scripts": {
    "start": "webpack-dev-server"
  },     
```

webpack-dev-server不仅可以监听到源文件代码的修改，实现自动打包，而且可以**自动打开浏览器，并自动刷新浏览器**，从而提升我们代码开发的效率。

通过file的形式打开html页面，就没办法去发ajax请求了，因为发ajax请求必须dist/index.html必须在一个服务器上，通过http协议的方式打开。

在devServer中可以添加proxy项，用来配置跨域代理地址，进行接口模拟，从而解决跨域问题；也可以配置端口号port。

扩充知识：可以使用express实现devServer创建本地http服务器的功能，需要安装expess和webpack-dev-middleware。

```
npm install express -D // express@4.16.4
npm install webpeck-dev-middleware -D // webpack-dev-middleware@3.4.0
```

```js
# server.js
const expess = require('express');// 创建http服务器
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');// webpack中间件，监听打包
const config = require('./webpack.config.js');
const complier = webpack(config); // webpack编译器

const app = expess();
app.use(webpackDevMiddleware(complier,{
    publicPath:config.output.publicPath
}))

app.listen(3000,()=>{
    console.log('server is running');
})
```

运行webpack方式：第一种为在命令行中运行webpack index.js; 第二种是在node中运行,如node server.js。

### Hot Module Replacement 热模块替换

webpack-dev-server在运行npm run start时，并不会生成dist目录并存放打包生成后的文件，而是将打包生成后的文件放在内存中，可以有效地提升打包的速度，让我们的开发更快。

HRM只替换页面中css的改变，而不改变页面中原有的js渲染的内容，方便我们调试css样式。修改webpack配置文件后，最好重启一下命令。

```js
devServer:{
		contentBase:'./dist',
		open:true,
		port:8080,
		hot:true, // 开启HotModuleReplacement功能
		hotOnly:true // 即使html未生效，浏览器也不自动刷新
	},
```

```js
const webpack = require('webpack');// webpack.config.js头部引入webpack
plugins:[
		new webpack.HotModuleReplacementPlugin()
],
```

当在一段代码中引入其他的模块的时候，如果你希望这个模块发生了变化，只去更新这个模块的代码，就要用的HRM技术了。需在webpack.config.js的devServer中配置hot和hotOnly项，在plugins中引入 HotModuleReplacementPlugin插件。

```js
// 要实现局部刷新需要使用到accept方法，接收两个参数，第一个是要变更的模块，第二个是变更的回调函数
if (module.hot) {
  module.hot.accept("./number", () => {
    document.body.removeChild( document.getElementById('number'))  
    number();
  })
}
```

### 使用Babel处理ES6语法

当使用npx webpack命令做打包，可以查看打包生成的main.js文件；而使用npm run start，用webpack-dev-server做打包，打包生成的文件都在内存中，无法查看main.js。

如果main.js中能够将ES6打包生成的语法转换成为ES5的语法，就能够兼容所有的浏览器，此时就需要借助Babel来实现，可访问其官方网站https://babeljs.io , 在setup - webpack 目录下找到其在webpack的详细配置。

babel-loader只是babel与webpack之间的一座桥梁，用来连接webpack，并不对ES6语法进行翻译。@babel/core是babel的一个核心库，能够让babel去识别js代码里的内容，把js代码转换成ast抽象语法树，最后将语法树编译成新的js语法。

```shell
# 安装babel-loader和@babel/core
npm install --save-dev babel-loader @babel/core // babel-loader@8.0.4 @babel/core@7.2.0
```

```js
# webpack.config.js
module: {
  rules: [
    { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader",
      options:{
        presets:["@babel/preset-env"]
    } 
    }
  ]
}
```

preset-env是真正将ES6转换成ES5语法的模块，里面包含了所有ES6翻译到ES5的语法翻译规则。

```shell
npm install --save-dev @babel/preset-env // @babel/preset-env@7.2.0
```

#### babel-polyfill配置

只有babel-loader和preset-env没办法解决变量或函数(例如：promise、map方法)在低版本浏览器中的识别，需要借助babel-ployfill，补充实现变量或函数在低版本的浏览器中被识别。

```shell
npm install --save @babel/polyfill@7.0.0 // @babel/polyfill@7.0.0
```

```js
#/src/index.js
import "@babel/polyfill";  // 使用@babel/polyfill
```

```js
# webpack.config.js 配置
module: {
    rules: [
	  { test: /\.js$/, exclude: /node_modules/, loader: 'babel-loader', 
	    options:{
        presets:[
            ['@babel/preset-env', {
              targets: {
                edge: "17",
                firefox: "60",
                chrome: "67",// 在chrome版本低于67时进行babel的翻译
                safari: "11.1",
              },
			  useBuiltIns:'usage' // 根据业务代码，按需加入ES6代码翻译
								}
            ]
        ]
    }},
}        
```

chrome: "67"表示在chrome版本低于67时进行babel的翻译，如果浏览器版本支持从ES6语法，就会忽略转译成ES5。polyfill的相关参数，可以去官网查看相应的配置。

在编写业务代码时，如果需要用到babel，可以参考上面的配置方案。但是，这个方案并非所有场景都能使用。

#### babel-plugin-transform-runtime

在开发一个类库、第三模块、或者组件库，如果用babel-pollyfill方案，会出现问题。因为pollyfill在注入类似Promise，map方法时，会通过全局变量的方式来注入，会污染全局环境。

安装 plugin-transform-runtime(参考: https://babeljs.io/docs/en/babel-plugin-transform-runtime ) :

```shell
npm install --save-dev @babel/plugin-transform-runtime //@7.2.0
```

此外还要安装 runtime 模块：

```shell
npm install --save @babel/runtime //@7.2.0
```

```js
# webpack.config.js配置
module: {
		rules: [
		{ 
			test: /\.js$/, 
			exclude: /node_modules/, 
			loader: "babel-loader",
			options:{
				"plugins": [["@babel/plugin-transform-runtime",{
			        "corejs": 2,
			        "helpers": true,
			        "regenerator": true,
			        "useESModules": false,
				}]]
			}
		},
       ......      
```

如果webpack.config.js中配置了"corejs":2，则还需要安装一个依赖包 , 否则会报promise模块找不到的错误，然后运行 npx webpack 打包，就不会有任何问题了:

```shell
npm install --save @babel/runtime-corejs2 //@7.2.0
```

babel的配置项会非常多，webpack.config.js中options的内容会非常长，可以在项目根目录下创建.babelrc文件，将options里的内容添加到.babelrc中。

```shell
#.babelrc
"plugins": [
	["@babel/plugin-transform-runtime",{
			        "corejs": 2,
			        "helpers": true,
			        "regenerator": true,
			        "useESModules": false,
				}]
			]
```

### Webpack 实现对React框架代码的打包

#### 配置 React 代码的打包

参考url: https://babeljs.io/docs/en/7.1.0/babel-preset-react 

可以通过 @babel/preset-react 来解析 react 中的 jsx 语法，首先需要安装 react&react dom;

```shell
npm install react react-dom --save //  react@16.6.3 react-dom@16.6.3 
```

想要使用webpack结合babel打包react的代码，还需要安装@babel/preset-react：

```shell
npm install --save-dev @babel/preset-react  // @babel/preset-react@7.0.0
```

同时.babelrc里也需要做相应的配置，.babelrc里文件的执行顺序是从下到上，从右到左。先把react里的代码进行转换，然后把转换后代码中的ES6代码部分进行转换为ES5。

```shell
{
    presets:[
                    ["@babel/preset-env",{
                       targets: {
                            edge: "17",
                            firefox: "60",
                            chrome: "67",
                            safari: "11.1",
                                 },
                       useBuiltIns:"usage"
                                        }
                    ],
                    "@babel/preset-react"
            ]
}
```

### Tree Shaking

如果在webpack.config.js配置了babel-loader相关的内容，同时.babelrc里加入了"useBuiltIns",那么在业务代码中就不需要引入polyfill。

```js
// import "@babel/polyfill"; 无需引入
```

Tree Shaking 的意思是把一个模块中没用的东西都摇晃掉，一个模块可以理解为一颗树。只引入我们需要的部分，不需要的部分通过 Tree Shaking帮我们摇晃掉，剔除掉。在webpack中，要实现Tree Shaking 我们应该怎么做呢?

首先Tree Shaking只支持ES Module的引入，即 import方式的引入，使用cont  add = require(...)等CommonJS的方式引入，Tree Shaking的方式是不支持的。这是因为import这种ES Module的引入，底层是一个静态引入方式，而CommonJS底层是动态引入的方式，所以Tree Shaking 只支持静态引入方式。

#### Tree Shakingの配置

mode:"development"下默认是没有Tree Shakin功能的，可以在webpack.config.js的plugins下面添加一个optimization的对象；同时在package.json中添加  "sideEffects":fale,意思是tree shaking 对所有的模块进行tree shaking,没有特殊处理的部分。

```js
# webpack.config.js
optimization:{
		usedExports:true
			},
```

```json
# package.json
{
  "name": "lesson2",
  "sideEffects":false,
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "webpack-dev-server"
  },
    ......
```

在mode：'development'环境下，tree shaking 并不会通过减少代码的方式，来处理多余模块，只是会做一个提示。 如果要排除某些文件不做tree shaking,可在package.json中添加sideEffects:['*.css']，没有需要排除的直接写 "sideEffects":false。

在mode:'production'环境下，webpack已经拥有一些自动的tree shaking配置，可以注释掉webpack.config.js中的optimization配置。但是，package.json中的sideEffects还是需要写的。

#### Development 和 Production 模式的区分打包

在开发环境下使用development，一旦在开发环境开发完代码，需要部署上线时，就要用的production模式。development 和 production 的差异主要在几个方面：

>1. 在开发环境中，sourcemap是非常完整的；在生产环境中，sourcemap是非常简洁的；
>2. 在开发环境中，代码一般不需要压缩；在生产环境中，代码一般是被压缩过的代码；

为了区分development和production的配置文件，可以分别创建webpack.dev.js 和 webpack.prod.js文件，在package.json的scripts做如下配置：

```shell
#package.json
"scripts": {
    "dev": "webpack-dev-server --config webpack.dev.js",
    "build": "webpack --config webpack.prod.js",
  },
```

