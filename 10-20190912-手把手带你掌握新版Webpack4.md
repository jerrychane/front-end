### 安装webpack	

```js
npm init / npm init -y (自动生成默项)
npm install webpack-cli --save-dev
```

### 运行webpack

```js
npx webpack index.js //用webpack翻译index.js文件
```

注意： 

1. npx 和npm 的区别，其实很简单，npx会在目录下的node_modules下面找webpack，没有就安装一个。npm 则先去全局，然后再去当前目录下的node_modules找webpack，没有就不找了；
2. devDependencies 和 dependencies的区别，devDependencies 指的是你本地开发环境下的依赖(比如webpack，babel以及一系列的loader等)；dependencies 指的是你生产环境下打包所需要的依赖(比如你项目中用到了lodash，那么你就应该配置到这个下边)

### webpack环境搭建

webpack是基于nodejs开发的模块打包工具。提升webpack打包速度，一定要安装最新稳定版本。

(1) node版本要使用最新稳定版；（2）webpack要使用最新版本；

### webpack的安装方式

**全局安装：**

`npm install webpack webpack-cli -g`; (安装时，如果npm安装很慢，建议使用手机分享热点，就不会有该问题了)

webpack-cli@3.1.2   webpack@4.26.0

全局安装特定版本：`npm install webpack@4.26.0 webpack-cli -g`;

不推荐使用webpack全局安装；卸载全局安装的webpack `npm uninstall webpack webpack-cli -g`

**项目中安装：**

`npm install webpack webpack-cli --save-dev   `  或者`npm install webpack webpack-cli -D`

其中--save-dev等价于-D；

安装特定版本：

`npm install webpack@4.26.0 webpack-cli --save-dev`

此时无法运行webpack命令，如果要运行webpakc命令，需要执行` npx webpack -v`, 输出webpack版本

`npm info webpack`  or  `npm view webpack versions`  当不知道某个版本号是否存在时，查看webpack的所有版本号

### webpack的配置文件

创建默认配置文件 --- webpack.config.js，默认文件名必须是wepack.config.js；若要修改默认文件名，可用以下命令：

```js
npx webpack --config  webpackconfig.js // 修改默认配置文件名为 webpackconfig.js
```

```js
// webpack.config.js
const path = require('path');
module.exports = {
    mode:'production', // 开发环境: development，bundle.js中代码不会被压缩
    entry : './src/index.js',
     /* entry :  {
        main: './src/index.js'
    },*/
    output : {
       filename:'bundle.js',
       path:path.resolve(__dirname,'dist')
    }
}
```

配置打包命令时，可用npm script 替代 npx webpack，需在package.json文件中进行配置，如下，运行npm run bundle即可

```json
scripts:{
    "bundle" : "webpack"
}
```

webpack-cli的作用就是使得我们可以使用 npx webpack 或 webpack 的命令。

### 什么是Loader

loader 本质是一个打包的方案，它知道对于某一个特定的文件，webpack应该怎样打包，因为webpack无法识别非.js结尾的模块，loader在module中配置。安装file-loader : `npm install file-loader --save-dev`。

```js
module:{
        rules:[{
            test:/\.(jpg|png|gif)$/,
            use:{
                loader:'file-loader',
                options:{
                    // placeholder 占位符语法
                    name:'[name]_[hash].[ext]', // 图片文件以原来的名字输出
                    outputPath:'images/'
                }
            }
        }]
    },
```

url-loader 除了能做 file-loader 做的事情，还能做额外的事情，url-loader会将图片转换成一个base64的字符串，安装 url-loader :`npm install url-loader --save-dev`; 当图片非常小时，

```js
module:{
        rules:[{
            test:/\.(jpg|png|gif)$/,
            use:{
                loader:'url-loader',
                options:{
                    // placeholder 占位符语法
                    name:'[name]_[hash].[ext]', // 图片文件以原来的名字输出
                    outputPath:'images/',
                    limit:2048 // 大于limit，生成图片文件; 小于limit，生成base64字符串
                }
            }
        }]
    },
```

### 使用 loader 打包静态资源(样式篇一)

为了使webpack能够识别css文件，需要引入 style-loader , css-loader; 其中css文件可以帮助我们识别几个.css文件之间的关系，最终帮我们合并成一段css；style-loader 是在得到 css-loader生成的内容之后，style-loader会将这段内容挂载在head部分，生成`<style>...</style>` ; 若要识别 .scss文件，还要引入 sass-loader。

安装loader：

```
npm install style-loader css-loader --save-dev
```

在webpack.config.js中配置:

```js
 {
   test: /\.css$/,
   use: ['style-loader','css-loader','sass-loader','postcss-loader'] 
 }
```

安装sass-loader:

```js
npm install sass-loader node-sass --save-dev
```

问题描述：执行上述命令后，执行 `npm run bundle` , 项目报错：`TypeError: this.getResolve is not a function`

错误原因：安装 sass-loader 的版本为最新版本，由于版本过高，而导致编译出错；

解决方法：进入npm官方网站，搜索sass-loader，查看发布的版本号，选择一年前或两年前的低版本。我选择的是7.3.0版本，继续执行安装命令：

```js
npm install sass-loader@7.3.0 node-sass --save-dev
```

在webpack中loader是有先后顺序的，按照**从下到上，从右到左**的执行顺序。例如以上文件中，首先通过sass-loader对sass文件进行翻译，翻译成css代码以后，给到css-loader，然后都处理好，通过style-loader挂载到页面上。

在写css3新特性时，一般要加浏览器厂商前缀，可以通过postcss-loader,自动添加各个浏览器厂商的前缀。首先安装postcss-loader,然后创建postcss.config.js文件，在该文件中写入配置规则。

```
npm i -D postcss-loader // 安装 post-loader
```

```
npm install autoprefixer -D // 安装 autoprefixer plugin
```

在postcss.config.js中配置：

```js
module.exports = {
    plugins: [
        require('autoprefixer')
    ]
}
```

**遇到的坑：**

```scss
//scss中写的代码
body {
    .avatar {
        width: 150px;
        height: 150px;
        transform: translate(100px,100px);
    }
}
```

结果在编译至css代码时，并未加上-webkit-前缀，需要在package.json中加入browserslist，其他地方无需任何修改，代码如下：

```json
"browserslist": [
    "> 1%",
    "last 2 versions",
    "not ie <= 8"
  ],
```

### 使用 loader 打包静态资源(样式篇二)

css-loader中常用的配置项：

```js
use: [
    'style-loader', 
    {
        loader:'css-loader',
        options:{ 
            importLoaders:2, // 以import引入的.scss文件，也要走postcss-loader和scss-loader的2个loader
             modules:true, // css文件的模块化打包，区分不同css的作用域
        }
    }, 
    'sass-loader',
    'postcss-loader'
]
```

使用file-loader打包字体文件:

```JS
{
    test: /\.(eot|ttf|svg|woff|woff2)$/,
        use: {
            loader: 'file-loader',
        } 
}
```

### 使用plugins让打包更便捷

安装html-webpack-plugin:

```
npm install html-webpack-plugin --save-dev // html-webpack-plugin@3.2.0
```

在webpack.config.js中的配置：

```js
var HtmlWebpackPlugin = require('html-webpack-plugin');
var path = require('path');

module.exports = {
  entry: 'index.js',
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'index_bundle.js'
  },
  plugins: [new HtmlWebpackPlugin({ // 实例化HtmlWebpackPlugin,在打包之后运行
      template:'src/index.html'
  })]
};
```

**HtmlwebpackPlugin的作用，会在打包结束后，自动生成一个html文件，并把打包生成的js,自动引入到这个html文件中。**

webpack中的plugin可以在webpack运行到某个时刻的时候，帮你做一些事情，类似于vue和react中的生命周期函数。

安装clean-webpack-plugin：

```
npm install clean-webpack-plugin --save-dev // clean-webpack-plugin@1.0.0
```

在webpack.config.js中的配置：

```js
var CleanWepackPlugin = require('clean-webpack-plugin');
var path = require('path');

module.exports = {
  entry: 'index.js',
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'index_bundle.js'
  },
  plugins: [new CleanWepackPlugin(['dist'])]// 实例化CleanWebpackPlugin，在打包前运行
};
```

clean-webpakc-plugin的作用是，在打包前删除上一次打包生成的文件。对比html-webpack-plugin和clean-webpack-plugin:  前者是在打包后执行(可通过控制台查看顺序)；后者是在打包前执行。

### Entry 与 Output 的基本配置

entry的入口文件可以写成一个字符串，表示打包文件的路径；output默认生成的文件为main.js。如果要将同一个文件，打包生成两个或多个文件，需要使用**占位符**( [name] / [hash] )。

```js
module.exports = {
	mode: 'development',
	entry: {
		main: './src/index.js',
		sub:'./src/index.js'
	},
	output: {
		filename: '[name].js', // name的值为entry中对象的key值，即main.js 和 sub.js
		path: path.resolve(__dirname, 'dist')
	}
}
```

在打包生成的文件前加入统一的地址,如引入CDN地址，需要在output中加上**publicPath**

```	js
module.exports = {
	mode: 'development',
	entry: {
		main: './src/index.js',
		sub:'./src/index.js'
	},
	output: {
        publicPath:'http://cdn.jerrychane.com',
		filename: '[name].js', // name的值为entry中对象的key值，即main.js 和 sub.js
		path: path.resolve(__dirname, 'dist')
	}
}
```

### SouceMap的配置

在开发者模式(mode:'development')，默认sourceMap已经配置,如果要关掉soucemap，可设置 devtool:'none';  souceMap是一个映射关系，可以映射出打包后文件的源代码所在源文件所在的位置。

开启这种映射关系，可设置devtool:'source-map',在打包时，会在dist目录下生成`*.js.map`的文件；若要去掉dist目录下的`*.js.map`文件可设置 devtool:'inline-source-map', 将*.js.map里内容直接放在打包文件的底部;

```js
devtools:'inline-source-map'; // 可以精确到哪一行的哪一列的记录
devtools:'cheap-inline-source-map'; // 可以精确到哪一行的记录，只映射业务代码，不会管第三方的loader
devtools:'cheap-module-inline-source-map';// 映射业务代码和第三方的loader
devtool:'eval';// 通过eval执行js代码，执行效率最快，性能最好，但复杂代码慎用
```

最佳实践：在开发环境中使用sourceMap，最好使用`devtool:'cheap-module-eval-source-map'`;在生产环境建议使用`devtool:'cheap-module-source-map'`;

### 使用WebpackDevServer提升开发效率

实现代码即时更新有三种方法：

第一种,在package.json中添加watch监听配置：

```js
"scripts": {
    "watch": "webpack --watch", // 运行npm run watch，监听源文件代码的修改，实现自动打包
  },
```

第二种，在webpack.config.js中添加devServer配置：

```js
npm install webpack-dev-server -D // 安装webpack-dev-server@3.1.10
```

```js
# webpack.config.js
devServer:{
		contentBase:'./dist', // web服务器的地址
        open:true // 自动打开浏览器
    	proxy: {
      			 '/api': 'http://localhost:3000' // 配置代理地址
        }
	},
# package.json
 "scripts": {
    "start": "webpack-dev-server"
  },     
```

webpack-dev-server不仅可以监听到源文件代码的修改，实现自动打包，而且可以**自动打开浏览器，并自动刷新浏览器**，从而提升我们代码开发的效率。

在devServer中可以添加proxy项，用来配置跨域代理地址，从而解决跨域问题；也可以配置端口号port。

可以使用express实现devServer创建本地http服务器的功能，需要安装expess和webpack-dev-middleware。

```
npm install express -D // express@4.16.4
npm install webpeck-dev-middleware -D // webpack-dev-middleware@3.4.0
```

```js
# server.js
const expess = require('express');// 创建http服务器
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');// webpack中间件，监听打包
const config = require('./webpack.config.js');
const complier = webpack(config); // webpack编译器
const app = expess();
app.use(webpackDevMiddleware(complier,{
    publicPath:config.output.publicPath
}))
app.listen(3000,()=>{
    console.log('server is running');
})
```

运行webpack方式：第一种为在命令行中运行webpack index.js;第二种是在node中运行,如node server.js。

### Hot Module Replacement 热模块替换

只替换页面中css的改变，而不改变页面中原有的js渲染的内容，方便我们调试css样式。

```js
devServer:{
		contentBase:'./dist',
		open:true,
		port:8080,
		hot:true, // 开启HotModuleReplacement功能
		hotOnly:true // 即使html未生效，浏览器也不自动刷新
	},
```

```js
const webpack = require('webpack');// webpack.config.js头部引入webpack
plugins:[
		new webpack.HotModuleReplacementPlugin()
	],
```











