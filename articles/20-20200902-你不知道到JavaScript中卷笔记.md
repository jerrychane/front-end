#### 第1章 - 异步：现在与将来

01、JavaScript 程序总是至少分为两个块：第一块现在运行；下一块将来运行，以响应某个事件。尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对6状态的修改都是在之前累积的修改之上的。

02、一旦有事件要运行，事件循环就会运行，直到队列清空。事件循环的每一轮成为一个tick。用户交互、IO和定时器会向事件队列中加入事件。

#### 第2章 - 回调

01、回调函数包裹或者说封装了程序的延续（continuation）。

02、回调会导致顺序的人脑计划和回调驱动的异步 JavaScript 代码之间的不匹配问题，使代码变得非常复杂，以至于无法维护和更新。

03、大脑对于事情的计划方式是线性的、阻塞的、单线程的，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难以理解的代码是坏代码，会导致坏 bug。

#### 第3章-Promise

01、绝大多数 JavaScript/DOM 平台新增的异步 API 都是基于 Promise 构建的。

02、通过 Promise, 调用 then(..) 实际上可以接受两个函数，第一个用于完成情况，第二个用于拒绝情况。

```js
add( fetchX(),fetchY() )
.then(
// 完成处理函数
    function(sum) {
		console.log(sum)
    },
// 拒绝处理函数
      function(err) {
		console.log(err)
    }
)
```

03、Promise 是一种用于封装和组合未来值的易于复用的机制。

04、new Promise ( function ( .. )  { .. } ) 中的 function 会立即执行，不会像 then( .. ) 中的回调一样异步延迟，它有两个参数，分别为 resolve 和 reject ， 这些都是 Promise 的决议函数。 resolve( .. ) 通常标识完成， 而 reject( .. ) 则标识拒绝。 

05、回调编码产生的信任问题：

* 调用回调过早；
* 调用回调过晚（或不被调用）；
* 调用回调次数过多或过少；
* 未能传递所需的环境和参数；
* 吞掉可能出现的错误和异常；